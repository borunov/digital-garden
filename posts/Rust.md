# Изучаю Rust

## Неизменные переменные
Не понимаю про неизменные переменные. Понимаю, зачем это сделано (вроде), но пока не могу прочувствовать насколько это частая ситуация. Ну то есть, если неизменяемых переменных будет «много», то супер и спасибо за дополнительный контроль, а если мало, то зачем это? Опять же, если менять значение структуры по указателю, то сам указатель вроде и неизменный, а данные поменялись. В Си это повсеместно, а в тут? В общем, надо понять в чём замысел.

Опять же, если мы инициализируем неизменяемую переменную значениями **не** из других переменных, то давайте использовать константы. Если только я не планирую потом затемнить (так вроде) эту переменную... В общем, пока всё туманно.

## Перечисления
Непонятно мне.
`for number in (1..4).rev() { 
	`println!("{number}!"); 
``}
Этот код печатает 3-2-1, а не 4-3-2-1. не понимаю логики в определении `(1..4)` по крайней мере пока. *Первое значение это начальная позиция, а второе – последнее плюс один. Во всяком случае так определяют срезы. Думаю и перечисления также.*

## Владение
Нужно обратить внимание.
Когда мы выделили из кучи память под что-то (объект какой-нибудь), а потом передали указатель на этот объект в функцию, то мы 
1. утратили владение этой памятью этой переменной
2. выход из функции освободил память и это неожиданно (см. последнюю строку и комментарий к ней)

`fn main() {
``    let s = String::from("hello");  // s comes into scope
``    takes_ownership(s);             // s's value moves into the function...
``                                // ... and so is no longer valid here
``}

`fn takes_ownership(some_string: String) { // some_string comes into scope
``    println!("{}", some_string);
``} // Here, some_string goes out of scope and `drop` is called. The backing
 `` // memory is freed.

## Ссылается но не владеет
`&s1` позволяет нам создать ссылку, которая _ссылается_ на значение `s1`, но не владеет им. Поскольку он не владеет им, значение на которое он указывает, не будет удалено, когда ссылка перестанет использоваться.

Когда функции имеют ссылки в качестве параметров вместо фактических значений, нам не нужно возвращать значения, чтобы вернуть право владения, потому что мы никогда не владели ими.

## Option<T>
Это очень, очень удобный способ на этапе компиляции убедиться, что значение переменной определено. Ну то есть нельзя «смешивать», складывать переменные Option<T> и просто T. Перед этим надо определиться, что делать, если вдруг переменная (которая типа Option<T>) не определена. Крайне продуманный и удобный способ избежать ошибок. Круто.

